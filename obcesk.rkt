#lang racket

(define ns (make-base-namespace))         

;; machine
(struct ev (e ρ σ κ) #:transparent
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "EV ~a\nρ ~a\nκ ~a" (ev-e v) (ev-ρ v) (ev-κ v))))
(struct ko (d σ κ) #:transparent
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "KO v ~a\nκ ~a" (ko-d v) (ko-κ v))))
(struct ifk (e1 e2 ρ) #:transparent)
(struct begink (es ρ) #:transparent)
(struct letk (x e ρ) #:transparent)
(struct letreck (x e ρ) #:transparent)
(struct setk (x ρ) #:transparent)
(struct membersetk (x e ρ) #:transparent)
(struct membersetvaluek (x a ρ) #:transparent)
(struct membergetk (x ρ) #:transparent)
(struct clo (e ρ) #:transparent
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "<clo ~a ~a>" (clo-e v) (clo-ρ v))))
(struct ratork (d ρ) #:transparent)
(struct randk (d es ds ρ) #:transparent)
(struct addr (a) #:transparent)

(define alloc
  (let ((a 0))
    (lambda ()
      (begin0
        a
        (set! a (add1 a))))))

(define (inject e0)
  (let ((ρ0 (hash))
        (σ0 (hash))
        (κ0 '()))
    (ev e0 ρ0 σ0 κ0)))

(define (final-state? s)
  (match s
    ((ko d σ '()) #t)
    (_ #f)))

(define (value-of s)
  (match s
    ((ko d _ _) d)))

(define (eval-sequence es ρ σ κ)
  (if (null? (cdr es))
      (ev (car es) ρ σ κ)
      (let* ((φ (begink (cdr es) ρ))
             (κ‘ (cons φ κ)))
        (ev (car es) ρ σ κ‘))))

(define (apply-procedure d ds σ κ)
  (match d
    ((clo `(lambda ,xs ,es ...) ρ)
     (let bind-loop ((xs xs) (ds ds) (ρ‘ ρ) (σ‘ σ))
         (if (null? xs)
             (eval-sequence es ρ‘ σ‘ κ)
             (let* ((a (alloc))
                    (ρ“ (hash-set ρ‘ (car xs) a))
                    (σ“ (hash-set σ‘ a (car ds))))
               (bind-loop (cdr xs) (cdr ds) ρ“ σ“)))))
    ((? procedure? d)
     (let ((d1 (apply d ds)))
       (ko d1 σ κ)))))

(define (step s)
  (match s
    ((ev (? symbol? x) ρ σ κ)
     (let* ((a (hash-ref ρ x 'undefined))
            (d (hash-ref σ a (lambda () (eval x ns)))))
       (ko d σ κ)))
    ((ev (and e `(lambda ,xs ,es ...)) ρ σ κ)
     (let ((d (clo e ρ)))
       (ko d σ κ)))
    ((ev `(quote ,e) ρ σ κ)
     (ko e σ κ))
    ((ev `(if ,e0 ,e1 ,e2) ρ σ κ)
     (let* ((φ (ifk e1 e2 ρ))
            (κ‘ (cons φ κ)))
       (ev e0 ρ σ κ‘)))
    ((ev `(let ((,x ,e0)) ,es ...) ρ σ κ)
     (let* ((φ (letk x es ρ))
            (κ‘ (cons φ κ)))
       (ev e0 ρ σ κ‘)))
    ((ev `(letrec ((,x ,e0)) ,es ...) ρ σ κ)
     (let* ((a (alloc))
            (ρ‘ (hash-set ρ x a))
            (φ (letreck x es ρ‘))
            (κ‘ (cons φ κ)))
       (ev e0 ρ‘ σ κ‘)))
    ((ev `(set! ,x ,e) ρ σ κ)
     (let* ((φ (setk x ρ))
            (κ‘ (cons φ κ)))
       (ev e ρ σ κ‘)))
    ((ev `(! ,e0 ,x ,e1) ρ σ κ)
     (let* ((φ (membersetk x e1 ρ))
            (κ‘ (cons φ κ)))
       (ev e0 ρ σ κ‘)))
    ((ev `(? ,e ,x) ρ σ κ)
     (let* ((φ (membergetk x ρ))
            (κ‘ (cons φ κ)))
       (ev e ρ σ κ‘)))
    ((ev `(begin ,es ...) ρ σ κ)
     (eval-sequence es ρ σ κ))
    ((ev `(object) ρ σ κ)
     (let* ((a (alloc))
            (d (hash))
            (σ‘ (hash-set σ a d)))
       (ko (addr a) σ‘ κ)))
    ((ev `(,e . ,es) ρ σ κ)
     (let* ((φ (ratork es ρ))
            (κ‘ (cons φ κ)))
       (ev e ρ σ κ‘)))
    ((ev d ρ σ κ)
     (ko d σ κ))
    ((ko d σ (cons (begink es ρ) κ))
     (eval-sequence es ρ σ κ))
    ((ko d σ (cons (ifk e1 e2 ρ) κ))
     (let ((e (if d e1 e2)))
       (ev e ρ σ κ)))
    ((ko d σ (cons (letk x es ρ) κ))
     (let* ((a (alloc))
            (ρ‘ (hash-set ρ x a))
            (σ‘ (hash-set σ a d)))
       (eval-sequence es ρ‘ σ‘ κ)))
    ((ko d σ (cons (letreck x es ρ) κ))
     (let* ((a (hash-ref ρ x))
            (σ‘ (hash-set σ a d)))
       (eval-sequence es ρ σ‘ κ)))
    ((ko d σ (cons (setk x ρ) κ))
     (let* ((a (hash-ref ρ x))
            (σ‘ (hash-set σ a d)))
       (ko 'undefined σ‘ κ)))
    ((ko d σ (cons (ratork '() ρ) κ))
     (apply-procedure d '() σ κ))
    ((ko d σ (cons (ratork es ρ) κ))
     (let* ((φ (randk d (cdr es) '() ρ))
            (κ‘ (cons φ κ)))
       (ev (car es) ρ σ (cons φ κ))))
    ((ko d0 σ (cons (randk d1 '() ds ρ) κ))
     (let* ((ds‘ (cons d0 ds))
            (ds“ (reverse ds‘)))
       (apply-procedure d1 ds“ σ κ)))
    ((ko d0 σ (cons (randk d1 es ds ρ) κ))
     (let* ((ds‘ (cons d0 ds))
            (φ (randk d1 (cdr es) ds‘ ρ))
            (κ‘ (cons φ κ)))
       (ev (car es) ρ σ (cons φ κ))))
    ((ko (addr a) σ (cons (membersetk x e ρ) κ))
     (let* ((φ (membersetvaluek x a ρ))
            (κ‘ (cons φ κ)))
       (ev e ρ σ (cons φ κ))))
    ((ko d0 σ (cons (membersetvaluek x a ρ) κ))
     (let* ((d1 (hash-ref σ a))
            (d1‘ (hash-set d1 x d0))
            (σ‘ (hash-set σ a d1‘)))
       (ko (addr a) σ‘ κ)))
    ((ko (addr a) σ (cons (membergetk x ρ) κ))
     (let* ((d0 (hash-ref σ a))
            (d1 (hash-ref d0 x)))
       (ko d1 σ κ)))
    ))

(define (machine-eval e)
  (let ((s0 (inject e)))
    (let explore-loop ((s s0))
      (if (final-state? s)
          (value-of s)
          (let ((s‘ (step s)))
            (explore-loop s‘))))))